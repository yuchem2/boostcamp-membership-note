## Node.js Q&A 정리 시간

### Q: Node.js를 만든 사람은?
> 이런 질문을 하는 이유는 만들어진 역사, 배경, 만든 사람 등을 파악하는 것이 기술을 익히는데 많은 도움이 됩니다.

Ryan Dah
### Q. nodeJS가 어떤 역할을 하나요?

브라우저 환경이 아닌 곳에서도 JavaScript를 실행할 수 있도록 돕는 역할을 합니다. Chrome V8 JavaScript 엔진 위에서 동작하는 JS 런타임 환경입니다. 비동기, 이벤트 기반 구조로 서버 개발에 많이 쓰이는 런타임 환경 중 하나입니다.
### Q. 브라우저 바깥에서 JS가 실행될 수 있도록 nodeJS가 어떻게 돕나요?

기존 브라우저에서 JS를 실행하기 위해 내장 엔진이 탑재되어 있음(크롬의 경우 V8, Firfox의 경우 SpiderMonkey)
NodeJS는 V8 엔진을 가지고 있어 브라우저가 없더라도 JS 코드를 해석하고 실행할 수 있음(터미널에서 console.log를 찍을 수 있는 이유도 nodeJS에 내장되어 있는 엔진을 이용하여 실행하기 때문)
### Q. Node.js는 V8 엔진 없이 작동할 수 있나요?

아니요, 현재의 Node.js는 V8 엔진 없이는 작동할 수 없습니다. Node.js는 V8을 JavaScript 엔진으로 사용하도록 설계되었으며, `fs`(파일 시스템), `net`(네트워크) 같은 핵심 모듈들도 모두 V8의 C++ 인터페이스에 맞춰 개발되었습니다. 따라서 V8이 없다면 JavaScript 코드를 실행할 수 없어 사실상 아무 기능도 하지 못합니다.

물론, Microsoft에서 Edge 브라우저의 Chakra 엔진을 Node.js에서 사용하려는 `node-chakracore` 같은 실험적인 프로젝트가 있긴 하지만, 이는 표준이 아닙니다.

### Q. V8 엔진은 어떻게 작동하나요?

V8은 Google이 C++로 개발한 고성능 오픈소스 JavaScript 엔진입니다. 가장 큰 특징은 인터프리터(interpreter) 방식 대신 JIT(Just-In-Time) 컴파일러를 사용하여 JavaScript 코드를 실행 시점에 직접 기계어(Machine Code)로 변환한다는 점입니다. 이 방식은 중간 단계인 바이트코드(bytecode)를 생략하기 때문에 실행 속도가 매우 빠릅니다.
### Q. V8은 JavaScript 코드를 어떻게 컴파일하나요?

V8은 '빠른 시작'과 '최적화' 두 가지 목표를 달성하기 위해 두 개의 컴파일러를 사용합니다.

1. 풀 컴파일러 (Full Compiler)
    - 먼저 코드를 빠르게 실행하기 위해, 깊은 분석 없이 JIT 코드를 신속하게 생성합니다.
    - 이 과정에서 **인라인 캐시(Inline Cache, IC)**라는 기술을 통해 코드 실행 중 타입 정보를 수집합니다.
2. 최적화 컴파일러 (Optimizing Compiler)
    - 자주 실행되어 "뜨거운(hot)" 함수가 발견되면, 최적화 컴파일러가 작동합니다.
    - 인라인 캐시에서 수집된 타입 정보를 바탕으로 매우 최적화된 코드를 다시 생성하여 성능을 극대화합니다.

최적화 해제 (De-optimization) 만약 최적화 컴파일러의 예측(예: '이 변수는 항상 숫자일 것이다')이 빗나가면, V8은 최적화된 코드를 버리고 다시 풀 컴파일러의 코드로 돌아가는데, 이를 최적화 해제라고 합니다. 이 과정은 성능 저하를 유발할 수 있습니다.
### Q. Node.js를 사용하면 어떤 이점이 있나요?

1. 비동기 & 이벤트 기반 (Asynchronous & Event-Driven)
	- Node.js의 모든 API는 비동기(논블로킹) 방식으로 작동합니다. 이는 서버가 특정 작업(API)이 끝날 때까지 멈춰서 기다리지 않고, 바로 다음 요청을 처리한다는 것을 의미합니다. 이전에 요청한 작업이 완료되면 '이벤트'가 발생하여 그 결과를 받아볼 수 있습니다.
2. 매우 빠른 속도 (Very Fast)
	- 구글 크롬의 V8 JavaScript 엔진을 기반으로 만들어져, JavaScript 코드를 기계어로 컴파일하는 과정이 매우 빠르고 최적화되어 있습니다.
3. 싱글 스레드지만 높은 확장성 (Single-Threaded but Highly Scalable)
	- Node.js는 이벤트 루프를 사용하는 싱글 스레드 모델을 채택했습니다. 요청이 들어올 때마다 새로운 스레드를 생성하는 전통적인 서버 방식과 달리, 논블로킹 방식으로 동작하여 하나의 스레드만으로도 훨씬 더 많은 요청을 효율적으로 처리할 수 있습니다. 이 덕분에 서버의 확장성이 매우 뛰어납니다.
4. 데이터 버퍼링 없음 (No Buffering)
	- Node.js 애플리케이션은 데이터를 한 번에 모아서 처리(버퍼링)하지 않습니다. 대신 데이터를 '청크(chunk)'라는 작은 단위로 나누어 스트리밍 방식으로 처리합니다. 이 덕분에 영상 스트리밍이나 대용량 파일 처리 시 메모리를 효율적으로 사용할 수 있습니다.
### Q: Node.js는 단일 스레드 기반인데 어떻게 여러 요청을 처리할 수 있나요?

Node.js 애플리케이션은 단일 스레드(Single Thread)를 기반으로 동작하지만, 이벤트 루프(Event Loop)와 콜백 함수(Callback)를 활용하는 비차단(Non-blocking) 방식을 통해 수많은 동시 요청을 효율적으로 처리합니다.

요청이 들어오면 Node.js는 파일 읽기나 데이터베이스 조회처럼 시간이 걸리는 작업을 직접 기다리지 않습니다. 대신, 해당 작업에 콜백 함수를 연결하고 실제 처리는 백그라운드로 넘긴 뒤 즉시 다음 요청을 받을 준비를 합니다. 이후 백그라운드에서 작업이 완료되면 이벤트가 발생하고, 이벤트 루프는 이 완료된 작업에 해당하는 콜백 함수를 실행시켜 응답을 보냅니다. 이러한 구조 덕분에 메인 스레드는 멈추는 일 없이 계속해서 새로운 요청을 처리할 수 있으며, 이것이 바로 Node.js가 적은 리소스로 높은 성능을 내는 핵심 원리입니다.
### Q: Node.js의 이벤트 루프는 무엇인가요?

Node.js가 단일 스레드임에도 불구하고 논 블로킹(Non-blocking) I/O 작업을 통해 높은 동시성을 처리할 수 있게 해주는 핵심 메커니즘입니다. 즉, 이벤트 루프는 Node.js 애플리케이션의 모든 비동기 작업을 끊임없이 확인하고 관리하는 무한 루프입니다. 이 루프는 다음의 역할을 수행합니다.

- 작업 위임: 메인 스레드는 시간이 오래 걸리는 I/O 작업(데이터베이스 쿼리, 파일 읽기, 네트워크 요청 등)이 발생하면 직접 처리하지 않고, libuv라는 백그라운드 라이브러리로 해당 작업을 위임합니다.
- 새로운 요청 처리: 메인 스레드는 위임 후 바로 다음 요청을 처리하러 갑니다. I/O 작업이 끝날 때까지 기다리며 멈추지 않습니다.
- 콜백 대기열 확인: 백그라운드에서 I/O 작업이 완료되면, 해당 작업에 연결된 콜백 함수가 이벤트 큐(Event Queue)에 추가됩니다.
- 콜백 실행: 이벤트 루프는 메인 스레드가 할 일이 없을 때마다 이벤트 큐를 확인하고, 큐에 있는 콜백 함수들을 하나씩 꺼내와서 실행합니다.

이러한 순환 구조 덕분에 Node.js는 한 번에 하나의 작업만 처리하는 것처럼 보이지만, 실제로는 I/O 작업이 완료될 때까지 기다리지 않고 다음 작업을 계속해서 받아들여 효율성을 극대화합니다.

### Q: Node.js의 핵심 모듈은 어떤 것이 있나요?

Node.js의 핵심 모듈은 별도의 설치 없이 바로 사용할 수 있는 내장 모듈입니다. Node.js 환경의 기반을 이루는 중요한 기능들을 제공하며, 주로 파일 시스템, 네트워크, 스트림 처리에 활용됩니다. 주요 핵심 모듈은 다음과 같습니다.

- `http`: 웹 서버와 클라이언트를 생성하는 데 사용되는 모듈입니다. HTTP 요청을 처리하고 응답을 보내는 기능을 제공하여 기본적인 웹 서버를 구축할 수 있습니다.
- `fs` (File System): 컴퓨터의 파일 시스템에 접근하여 파일을 읽고, 쓰고, 삭제하는 등 파일과 디렉터리를 조작하는 기능을 제공합니다. 동기 및 비동기 방식으로 모두 사용할 수 있습니다.
- `path`: 파일 경로를 다룰 때 사용되는 유틸리티 모듈입니다. 운영체제에 관계없이 경로를 병합하거나, 파일 확장자를 추출하는 등의 작업을 효율적으로 처리할 수 있습니다.
- `os`: 운영체제와 관련된 정보를 얻는 데 사용됩니다. 예를 들어, CPU 정보, 메모리 상태, 네트워크 인터페이스 등을 확인할 수 있습니다.
- `url`: URL 문자열을 파싱(parsing)하고 분석하는 데 사용됩니다. 쿼리 문자열(query string)을 쉽게 추출하거나 URL의 각 구성 요소를 다룰 수 있게 해줍니다.
- `events`: 이벤트 기반 프로그래밍을 위한 핵심 모듈입니다. `EventEmitter` 클래스를 제공하여 사용자 정의 이벤트를 만들고, 이벤트를 발생시키고, 이벤트 리스너를 등록하는 기능을 구현할 수 있습니다.
- `stream`: 데이터를 작은 덩어리(chunk)로 나누어 처리하는 스트림 기능을 제공합니다. 대용량 파일이나 네트워크 데이터를 다룰 때 메모리 효율성을 높이는 데 필수적입니다.
- `util`: 여러 가지 유용한 유틸리티 함수들을 제공합니다. 주로 비동기 함수를 다루거나, 객체를 검사하는 등의 보조적인 역할을 수행합니다.
### Q: Node.js에서 사용되는 비동기 프로그래밍 방식에 대해 설명해주세요

Node.js에서 사용되는 비동기 프로그래밍 방식은 콜백(Callback), 프로미스(Promise), Async/Await 문법이 있습니다.

1. 콜백(Callback): 가장 기본적인 비동기 처리 방식입니다. 비동기 작업이 완료되면 실행될 함수를 다른 함수의 인자로 전달하는 방식입니다.
    - Node.js 초기부터 사용되어 익숙하며, 간단한 작업에는 직관적입니다.
    - 여러 비동기 작업이 중첩될 경우 코드가 깊숙히 중첩되어 가독성이 떨어지는 콜백 지옥 문제가 발생합니다. 에러 처리가 복잡해지기도 합니다.
2. 프로미스(Promise): 콜백 지옥 문제를 해결하기 위해 도입된 패턴입니다. 비동기 작업의 최종 성공 또는 실패를 나타내는 객체입니다.
    - 콜백 지옥을 해결하여 코드를 더 깔끔하고 읽기 쉽게 만듭니다. 성공과 실패 로직이 명확하게 분리됩니다.
    - 여전히 `.then()` 체인이 길어지면 복잡해질 수 있습니다.
3. Async/Await: ES2017에 도입된 문법으로, 프로미스를 기반으로 하여 비동기 코드를 마치 동기 코드처럼 작성할 수 있게 해주는 패턴입니다. 현재 가장 많이 사용되는 방식입니다.
    - 비동기 코드를 동기 코드처럼 순차적으로 작성하여 로직을 쉽게 이해할 수 있습니다.
    - `try...catch` 블록을 사용해 동기 코드와 동일한 방식으로 에러를 처리할 수 있습니다.
    - `async` 함수는 항상 `Promise`를 반환하므로, `async/await`의 작동 원리를 이해하기 위해서는 `Promise`에 대한 기본 지식이 필요합니다.
### Q: Node.js에서 에러 처리 전략은 어떻게 구현하나요?

에러 처리 방식은 동기적 작업과 비동기적 작업에 따라 다르게 접근해야 합니다.

1. 동기적 에러 처리: `try...catch`
    - 가장 기본적인 방법으로, 코드가 순차적으로 실행될 때 발생하는 에러를 잡는 데 사용됩니다.
2. 비동기적 에러 처리: `Promise`와 `async/await`
    - Node.js의 비동기적 특성 때문에 `try...catch`만으로는 비동기 작업의 에러를 처리할 수 없습니다. 따라서 `Promise`의 `.catch()`나 `async/await`의 `try...catch`를 사용해야 합니다.
3. 중앙 집중식 에러 핸들링
    - 애플리케이션 전체의 에러를 한곳에서 관리하면 코드의 일관성과 유지보수성이 높아집니다. Express.js 같은 프레임워크에서는 에러 핸들링 미들웨어를 사용합니다.
4. 프로세스 에러 핸들링
    - 예상치 못한 치명적인 에러(Uncaught Exception)나 Promise 거부(Unhandled Rejection)가 발생하면 Node.js 프로세스가 강제로 종료될 수 있습니다. 이를 방지하기 위해 `process` 객체의 이벤트를 사용합니다.
### Q. 패키지 매니저에 대해 설명하고 각 매니저 별 차이점을 비교해주세요

Node.js 생태계에서 패키지를 관리하거나 실행하는 도구

- npm: Node.js 설치 시 기본 포함되는 패키지 매니저, `package.json`에 기록된 라이브러리를 설치/관리, 설치 시 기본적으로 `node_modules`에 라이브러리를 풀어서 저장
- pnpm: 상대적으로 최신 등장, 중복된 패키지를 실제로 복사하지 않고 링크를 사용하기에 디스크 공간 절약과 설치 속도 빠름
- yarn: npm의 단점을 개선하려고 만든 대안, 설치 속도가 빠르며 `yarn.lock`으로 버전 관리가 더 엄격함
### Q. npm과 npx의 차이점

npm은 주로 프로젝트의 의존성을 관리하고 패키지를 설치, 업데이트, 삭제하는 데 사용되는 반면, npx는 npm 레지스트리에 있는 패키지를 설치 없이 즉시 실행하거나, 일회성으로 패키지를 실행하는 데 사용됩니다.

쉽게 말해, npm은 프로젝트의 기반이 되는 패키지들을 관리하고 안정적으로 유지하는데 사용되고 npx는 패키지를 일시적으로 사용할 때 사용된다.

###  Q: Node.js는 단일 스레드 애플리케이션인가요?
 
 Node.js 의 메인 이벤트 루프는 단일스레드이지만, 전체 Node.js 애플리케이션은 멀티 스레드로 동작한다.
 
 - 단일 스레드 부분
	 - 메인 이펜트 루프와 JS 코드를 실행
	 - 콜백, Promise, async/await 처리
 - 멀티 스레드 부분
	 - **libuv의 스레드 풀**
	 - 파일 I/O, DNS 조회, CPU 집약적 암호화 작업 등
	 - Worker Threads API
## 0820 마스터 클래스 학습
> - Node.js 공식 문서를 기반으로 사용법을 익힌다.
> - Node.js의 구성요소들과 동작 원리에 대해 이해한다.
> - LibUV가 무엇인지 설명할 수 있다.
> - LibUV를 위해 OS단에서 지원하는 기능이 무엇인지 설명할 수 있다.

Node.js는 JS runtime (실행환경)으로, 브라우저, JVM 등과 유사한 개념

Javascript는 브라우저에서 스크립트를 실행시키기 위한 언어. 정적인 페이지 말고 더 복잡한 작업을 수행하고 싶어서 만들어졌고, DOM 제어를 위한 언어이다. 

하지만, 과거에는 매우 느린 속도로 문제가 발생했다. (실행시킬 때 동적인 언어 + 인터프리터 언어라는 특징 + 성능이 안좋은 브라우저 Mozila, 익스플로러 등)

-> 한 초등학생이 오픈소스 프로젝트를 만들었고 이 브라우저가 firefox 웹 브라우저의 전신이 되었음.

크롬이라는 브라우저가 등장하면서 V8 엔진이 등장하였다. (렌더링 엔진-Blink,J JS 엔진-V8) 

V8 엔진은 JS 엔진으로, 기존 JS보다 매우 높은 성능을 이끌어낼 수 있었다. 이러한 이유는 JIT 컴파일러(C++ 최적화)를 이용한 까닭이었다. 

즉, 핫 코드를 인터프리터 대신 JIT 컴파일러가 컴파일함으로써 속도를 증가시켰다. 이에 비해 일반적인 코드는 인터프린터가 실행시킨다.

핫코드와 콜드코드를 구분하는 것은 단순히 코드를 많이 실행시키는 것을 확인하는 것이다. 왜 이렇게 하는 지는, 컴파일 시간이 오래걸리기 때문에 핫 코드만 컴파일을 하는 것이다.

==> V8은 JIT 컴파일러(동적 컴파일링)을 통해 JS의 성능을 매우 높였다.

JS의 성능이 높아지면서, 일반적인 용도(general purpose)로 사용하고 싶어 Node.js가 등장하게 되었다.

## 학습 추가 포인트

- Chrome V8, Blink
- Node.js 역사, 만든 이유, 만든 사람
- Node.js의 구성요소들과 동작 원리
- 논블로킹 vs 블로킹
- Node.js 디버깅 도구
