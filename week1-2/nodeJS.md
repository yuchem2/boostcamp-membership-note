# Node.js
## 개요
**Node.js**는 **V8 엔진**을 기반으로 구축된 **자바스크립트 런타임**입니다. 과거에는 브라우저에서만 동작하던 자바스크립트를, 서버를 비롯한 다양한 환경에서 실행할 수 있게 해주는 실행 환경이라고 할 수 있습니다.
## 탄생과 역사
초창기 자바스크립트는 브라우저 안에서만 실행되는 언어였고, 속도 또한 느렸습니다. 당시 대부분의 브라우저 엔진이 자바스크립트를 한 줄씩 해석하는 인터프리터 방식으로 동작했기 때문입니다.

2008년, 구글은 크롬 브라우저와 함께 **V8 엔진**을 공개했습니다. V8은 인터프리터 방식의 한계를 극복하기 위해 **JIT(Just-In-Time) 컴파일러**를 도입했습니다. 실행 중 자주 사용되는 코드(핫 코드)를 감지해 기계어로 변환하여 실행 속도를 크게 향상시킨 것이죠. 이 혁신으로 자바스크립트는 단순히 브라우저용 언어에서 벗어나, 고성능 엔진 위에서 동작할 수 있는 언어로 도약했습니다.

이 무렵, 라이언 달(Ryan Dahl)은 기존 서버 환경의 한계를 주목했습니다. 당시 널리 사용되던 웹 서버는 요청마다 스레드를 생성하거나 스레드 풀을 활용하는 방식이 많았는데, 대규모 동시 접속이 발생하면 스레드 관리에 막대한 비용이 들었습니다.

달은 이 문제를 해결하기 위해 **이벤트 루프 기반의 비동기 I/O 모델**을 구상했고, 이를 구현하는 엔진으로 높은 성능을 자랑하는 V8을 선택했습니다. 그 결과 2009년, **Node.js**가 탄생했습니다. Node.js는 싱글 스레드 기반의 이벤트 주도형 아키텍처 덕분에 가볍고 효율적인 서버를 구현할 수 있었고, 자바스크립트는 브라우저를 넘어 서버 개발까지 아우르는 언어로 자리 잡게 되었습니다.
## 핵심 구성 요소와 동작 원리

Node.js는 두 가지 핵심 요소인 **V8**과 **LibUV**를 기반으로 작동합니다.
### V8 Engine (자바스크립트 코드 실행)
V8은 자바스크립트를 빠르게 실행하기 위해 **바이트코드와 JIT 컴파일**을 함께 사용합니다.
- **Ignition:** 자바스크립트를 바이트코드로 변환하고 실행하며, 코드 실행 패턴을 관찰합니다.
- **TurboFan:** 자주 실행되는 `핫 코드`를 최적화된 기계어로 JIT 컴파일하여 실행 속도를 크게 향상시킵니다.
### LibUV (비동기 I/O를 담당하는 C++ 라이브러리)
Node.js의 논블로킹 I/O 모델은 LibUV라는 C++ 라이브러리에 의해 구현됩니다.
#### 이벤트 루프(Event Loop)
- 자바스크립트 코드 실행, 비동기 작업 처리, 콜백 실행을 관리합니다.
- 이벤트 루프는 다음과 같은 단계(Phases)로 동작합니다
    1. **Timers** – `setTimeout`, `setInterval`의 콜백 실행.
    2. **Pending Callbacks** – 일부 시스템 작업(예: TCP 에러 처리) 콜백 실행.
    3. **Idle, Prepare** – 내부적으로 사용 (일반 개발자는 잘 안 씀).
    4. **Poll** – 새로운 I/O 이벤트 확인, I/O 관련 콜백 실행, 이벤트가 없다면 대기.
    5. **Check** – `setImmediate`의 콜백 실행.
    6. **Close Callbacks** – 소켓 등 리소스 종료 콜백 실행.
- 이벤트 루프는 **콜 스택(Call Stack)과 콜백 큐(Callback Queue)** 를 오가며, 스택이 비었을 때 큐에서 대기 중인 콜백을 꺼내 실행합니다.
#### 스레드 풀(Thread Pool)
- 일부 작업은 OS 차원에서 비동기 처리가 불가능합니다 (예: 파일 시스템 I/O, 압축, 암호화 등)
- 이런 경우 Node.js는 **LibUV의 스레드 풀(기본 4개, 환경 변수 `UV_THREADPOOL_SIZE`로 조정 가능)** 을 활용합니다.
- 작업이 완료되면 스레드 풀에서 결과를 이벤트 루프에 다시 전달하고, 루프가 해당 콜백을 실행합니다.
#### OS별 I/O API 활용
LibUV는 내부적으로 각 OS에 최적화된 비동기 I/O API(Linux의 `epoll`, macOS의 `kqueue`, Windows의 `IOCP` 등)를 사용합니다.
### 전체 동작 흐름
1. **자바스크립트 코드 실행**: V8이 싱글 스레드에서 코드를 실행
2. **비동기 작업 요청**: 파일 읽기, 네트워크 요청 등은 LibUV로 전달
3. **작업 처리**
    - OS에서 지원하는 경우: OS의 비동기 I/O API로 처리
    - 지원하지 않는 경우: LibUV의 스레드 풀에서 처리
4. **콜백 전달**: 완료된 결과가 이벤트 루프의 큐에 등록됨
5. **이벤트 루프 실행**: 메인 스레드가 유휴 상태일 때 큐의 콜백을 실행
## Node.js의 철학과 특징
- **비동기 & 이벤트 기반(Asynchronous, Event-Driven)**: 요청을 기다리지 않고 다음 작업을 수행하여 높은 동시성을 지원합니다.
- **싱글 스레드(Single-Threaded)**: 메인 루프는 싱글 스레드이지만, LibUV와 OS 기능을 활용해 멀티스레드 장점도 활용합니다.
- **npm(Node Package Manager)**: 세계 최대 규모의 오픈소스 패키지 생태계를 제공하여 Node.js 생태계 성장을 가속했습니다.
- **빠른 실행 속도**: V8 기반의 JIT 최적화 덕분에 자바스크립트 실행 속도가 매우 빠릅니다.
## 블로킹과 논블로킹

### 블로킹 (Blocking)
- **특징**: 작업이 끝날 때까지 **다음 코드 실행이 멈춤**
- 예시

	```js
	const fs = require("fs");
	const data = fs.readFileSync("file.txt", "utf8"); // 블로킹
	console.log(data); 
	console.log("Done");
	```

- 실행 순서: `[파일 읽기 완료] → [data 출력] → [Done 출력]`
### 논블로킹 (Non-Blocking)

- **특징**: 작업 요청 후 **즉시 다음 코드 실행**, 완료 시 콜백이나 Promise로 결과 전달
- 예시

	```js
	const fs = require("fs");
	fs.readFile("file.txt", "utf8", (err, data) => {
	  if (err) throw err;
	  console.log(data); // 완료 후 실행
	});
	console.log("Done"); // 바로 실행됨
	```

- 실행 순서: `[Done 출력] → [파일 읽기 완료 후 data 출력]`
### Node.js에서 논블로킹
- Node.js는 **기본적으로 논블로킹 I/O 모델**을 사용
- 이벤트 루프와 LibUV를 통해 다수의 동시 요청 처리 가능
- 단, CPU 연산이 오래 걸리는 블로킹 작업은 **이벤트 루프를 막아 전체 서버 응답 지연** → Worker Threads, Cluster로 보완 가능

## Node.js와 브라우저의 차이
- **제공 API 차이**
    - 브라우저: `document`, `window` 등 DOM 및 Web API 제공
    - Node.js: `fs`, `http`, `net` 등 서버·파일 시스템 관련 API 제공
- **전역 객체**
    - 브라우저: `window`
    - Node.js: `global`
- **모듈 시스템**
    - Node.js: CommonJS(`require`)와 ES 모듈(`import`) 모두 지원
    - 브라우저: 주로 ES 모듈(`import`)
## 활용 사례
- **웹 서버 개발**: Express.js, Fastify 등
- **프론트엔드 빌드 도구**: Webpack, Vite, Next.js 등
- **CLI 도구**: ESLint, Prettier, npm/yarn
- **실시간 서비스**: 채팅 서버, 스트리밍 서버
- **마이크로서비스 및 API 서버**: 대규모 트래픽 처리에 최적화
## 한계
- **CPU 연산 집약적 작업에는 부적합**: 싱글 스레드라 메인 이벤트 루프가 막힐 수 있음 
- **멀티코어 활용 한계**: 기본적으로 하나의 스레드에서 동작 → 워커 스레드(Worker Threads), 클러스터링(Clustering)으로 보완 가능.
- **콜백 지옥(Callback Hell)**: 비동기 코드가 복잡해질 수 있으나, `Promise`, `async/await`으로 개선 가능.
## Node.js 디버깅 도구
Node.js는 서버 사이드에서 동작하기 때문에 **에러 추적**과 **코드 흐름 분석**을 위한 디버깅 도구가 필수적입니다.
### 기본 제공 디버깅
- **`console.log` 디버깅**
    - 가장 단순한 방식. 변수 값, 실행 흐름, 상태 등을 출력하여 확인.
    - 간단하지만 코드가 지저분해질 수 있음.
- **`node inspect` (내장 디버거)**: `node inspect app.js`
    - Node.js에 내장된 디버거를 실행
    - 브레이크포인트 설정, 변수 값 확인, 실행 흐름 제어 가능
    - CLI 환경에서 사용
- **`--inspect` 플래그**: `node --inspect app.js`
    - Node.js 애플리케이션을 디버그 모드로 실행
    - 브라우저(크롬 개발자 도구)나 외부 IDE에서 디버깅 가능
    - `--inspect-brk`를 사용하면 앱 시작 시 첫 줄에서 중단
### IDE & 에디터 디버깅
- **VS Code 디버거**
    - 가장 많이 쓰이는 Node.js 디버깅 도구
    - `launch.json` 설정을 통해 브레이크포인트 디버깅 지원
    - `--inspect` 모드와 연결 가능
- **WebStorm (JetBrains)**
    - Node.js 프로젝트에 특화된 디버깅 환경 제공
    - Express.js, Mocha 같은 프레임워크 통합 디버깅 지원
### 외부 도구 & 라이브러리
- **nodemon**
    - 코드 변경 시 자동으로 서버를 재시작
    - 개발 중 빠른 피드백을 제공
- **pm2**
    - 프로덕션 환경에서 사용되는 프로세스 관리자
    - 모니터링과 로그 추적을 통해 디버깅에 도움
- **debug 모듈**
    - 범용 로깅 라이브러리
    - 네임스페이스 기반으로 로그를 관리하여 필요한 부분만 출력 가능
## HTTP 요청 처리 흐름: 브라우저 → Node.js
주소창에서 URL을 입력하고 엔터를 눌러 특정 리소스를 요청한다고 가정할 때, 전체 과정은 다음과 같이 정리할 수 있습니다.
1. **브라우저에서 요청 생성**
    - 사용자가 주소창에 URL을 입력하거나 버튼을 클릭하면, 브라우저가 해당 리소스에 대한 HTTP 요청을 생성합니다.
    - TCP/IP를 통해 서버로 요청 전송.    
2. **Node.js 서버가 요청 수신**
    - Node.js 프로세스가 TCP 소켓을 통해 요청을 수신.
    - Express가 라우팅을 통해 요청을 처리할 핸들러 결정.
3. **핸들러에서 I/O 요청 발생**
    - 데이터베이스 조회, 파일 읽기, 외부 API 호출 등 시간이 걸리는 작업 발생.
    - Node.js는 **이벤트 루프와 LibUV**를 통해 비동기 처리로 위임.
4.  **LibUV를 통한 I/O 처리**
    - OS에서 직접 비동기 처리가 가능하면 OS의 API(예: Linux `epoll`) 사용.
    - OS에서 비동기 처리를 지원하지 않으면 **LibUV 스레드 풀**에서 블로킹 작업 처리.
    - 작업 완료 시 결과와 콜백을 이벤트 루프에 전달.    
5. **이벤트 루프에서 콜백 실행**
    - 이벤트 루프가 콜백 큐에서 작업 완료 콜백을 꺼내 실행.
    - Express 핸들러가 결과를 받아 HTTP 응답을 생성.
6. **Node.js가 응답 전송**
    - HTTP 응답을 브라우저로 전송.
    - 이 과정에서 다른 요청을 블로킹하지 않고 계속 처리 가능.
7. **브라우저가 응답 수신**
    - 브라우저가 서버 응답을 수신하고 렌더링.
    - 사용자에게 최종 결과 표시.
## 출처
- Hounx님의 마스터 클래스 강의
- https://nodejs.org/ko/learn/getting-started/introduction-to-nodejs
- https://v8.dev/blog/ignition-interpreter
- https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4